<?php


/**
 * Skeleton subclass for representing a row from the 'tracks' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * 02/03/11 19:41:23
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class Tracks extends BaseTracks {

	/**
	 * Initializes internal state of Tracks object.
	 * @see        parent::__construct()
	 */
	public function __construct()
	{
		// Make sure that parent constructor is always invoked, since that
		// is where any default values for this object are set.
		parent::__construct();
	}

	public function getTracksTimeFormatted()
	{
		//return $this->getTracksTime();//5:41
                return number_format($this->getTracksTime()/100, 2, ':', '');
	}
        
	public function getTracksArtistUppercase()
	{
		return strtoupper($this->getTracksArtist());
	}

        public function getTracksTitleShorted() {
            $title = $this->getTracksTitle();
            if(strlen($title)>sfConfig::get('app_tracklist_max_name_length')) {
                $title = substr($title, 0, sfConfig::get('app_tracklist_max_name_length')).'..';
            }
            return $title;
        }


        public function isTrackNew() {
            $track_date = $this->getTracksDate('U');
            return((time() - 86400 * ConfigurationsPeer::getNewLabelPeriod())<$track_date);
        }

        public function isTrackActive() {
            return ($this->getTracksAccepted() && !$this->getTracksDeleted());
        }

        public function isInWishlist() {
            $profile = ProfilesPeer::getCurrentProfile(); // wishlist jest tylko dla zalogwoanych
            if(is_object($profile)) {
                $criteria = new Criteria();
                $criteria->add(ProfilesWishlistsPeer::PROFILES_ID, $profile->getProfilesId());
                $criteria->add(ProfilesWishlistsPeer::TRACKS_ID, $this->getTracksId());
                return ProfilesWishlistsPeer::doCount($criteria);
            }
            return false;
        }

        /*
         * Generuje unikalny URL
         */
        public function generateTracksPath($string) {
            $path_size = TracksPeer::getTableMap()->getColumn(TracksPeer::TRACKS_PATH)->getSize();
            $path = Smashin::generate_url($string, $path_size);
            $counter=1;
            while(true) {
                $criteria = new Criteria(TracksPeer::DATABASE_NAME);
                if($this->getTracksId()) $criteria->add(TracksPeer::TRACKS_ID, $this->getTracksId(), Criteria::ALT_NOT_EQUAL);
                $criteria->add(TracksPeer::TRACKS_PATH, $path);
                if(TracksPeer::doSelectOne($criteria)) {
                    $add_end = '-'.$counter;
                    $path = Smashin::generate_url($string, $path_size-strlen($add_end)).$add_end;
                    $counter++;
                } else break;
            }
            return $path;
        }

        public function save(PropelPDO $con = null) {
            if ($this->isNew()) $this->setTracksDate(time());
            $path = $this->generateTracksPath($this->getTracksArtist().'-'.$this->getTracksTitle());
            $this->setTracksPath($path);
        
            return parent::save($con);
        }

        public function addStats() {
            $ip_address = $_SERVER['REMOTE_ADDR'];

            $criteria = new Criteria();
            $criteria->add(TracksPlayedPeer::TRACKS_ID, $this->getTracksId());
            $criteria->add(TracksPlayedPeer::TRACKS_PLAYED_DATE, date('Y-m-d'), Criteria::GREATER_EQUAL); // dziś, nowsze niż
            $criteria->add(TracksPlayedPeer::TRACKS_PLAYED_IP_ADDRESS, $ip_address);
            $amount = TracksPlayedPeer::doCount($criteria);
            if(!$amount) {
                $played = new TracksPlayed();
                $played->setTracksPlayedDate(date('U'));
                $played->setTracksPlayedIpAddress($ip_address);
                $played->setTracks($this);
                $played->save();
            }
        }

        public function setTracksTitle($v)
	{
		if ($v !== null) {
			$v = (string) $v;
                        $v = Smashin::capitalizeWords($v, ' -(.,'); // z dużych liter każde słowo
		}


		return parent::setTracksTitle($v);
	} // setTracksTitle()

        /**
         *
         * @param <int> $number od 1 do 3 - numer gatunku
         */
        public function getTracksGenresName($number) {
            $criteria = new Criteria();
            $criteria->setLimit(1);
            $criteria->setOffset($number-1); // bo liczy od 0 a nie od 1
            $genres = $this->getTracksGenress($criteria);
            return $genres[0]->getGenres()->getGenresName();
        }

        public function getTracksGenresObject($number) {
            $criteria = new Criteria();
            $criteria->setLimit(1);
            $criteria->setOffset($number-1); // bo liczy od 0 a nie od 1
            $genres = $this->getTracksGenress($criteria);
            return $genres[0];//->getGenres();
        }



} // Tracks
